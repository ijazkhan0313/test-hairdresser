import{A as x}from"./lEC4QW_W.js";import{i as u}from"./O97EOHsH.js";import{i as h}from"./DQqw_gti.js";import{u as m,c as p}from"./C-QmXMO2.js";import{_ as v,o as d,c as f,a as r,d as A,t as C,l as N,w as g,g as E,r as G,p as T,e as y}from"./C2egFmNW.js";import"./C4iS2aBk.js";const _={components:{AudioElement:x},data(){return{audioList:[{id:1,title:"Lagoon",src:window.location.origin+"/sounds/lagoon.m4a"},{id:2,title:"Forest",src:window.location.origin+"/sounds/forest.m4a"},{id:3,title:"Meadow",src:window.location.origin+"/sounds/meadow.m4a"},{id:4,title:"Tropics",src:window.location.origin+"/sounds/tropics.m4a"}],noise:{id:5,title:"Noise",src:window.location.origin+"/masking/noise.flac"},selectedAudioTitle:"",currentElement:{},createdNodes:{},musicPatch:u,noisePatch:h,audioContext:null,playState:!1}},computed:{selectedAudio(){return this.audioList.find(e=>e.title===this.selectedAudioTitle)||null},checkContextCompatibility(){const e=Object.values(this.createdNodes),s=e.filter(n=>n.context!==this.audioContext);return e.length===e.length-s.length?!0:(this.handleIncompatibeError(s),!1)},isPlaying(){return this.playState}},beforeUnmount(){this.disconnectNodes(),this.audioContext&&this.audioContext.close(),this.audioContext=null},mounted(){this.audioContext=m().getContext(),this.selectAudioByTitle(this.audioList[0].title),this.addUserNavigationHandling(),this.musicPatch=u,this.noisePatch=h},methods:{changeNoiseVolume(e){this.createdNodes.noiseGain&&(this.createdNodes.noiseGain.gain.linearRampToValueAtTime(e,this.createdNodes.noiseGain.context.currentTime+.3),this.noiseGain=this.createdNodes.noiseGain.gain.value)},changeMusicVolume(e){this.createdNodes.musicGain&&(this.createdNodes.musicGain.gain.linearRampToValueAtTime(e,this.createdNodes.musicGain.context.currentTime+.3),this.musicGain=this.createdNodes.musicGain.gain.value)},addUserNavigationHandling(){"mediaSession"in navigator&&(navigator.mediaSession.setActionHandler("nexttrack",()=>{this.skip("next")}),navigator.mediaSession.setActionHandler("previoustrack",()=>{this.skip("previous")}))},getSong(e,s){let t=this.audioList.findIndex(o=>o.title===e)+(s==="next"?1:-1);return t>=this.audioList.length?t=0:t<0&&(t=this.audioList.length-1),this.audioList[t]},skip(e){const s=this.getSong(this.selectedAudioTitle,e);this.selectAudioByTitle(s.title)},resumeContext(){this.audioContext.state==="suspended"&&this.audioContext.resume()},stopContext(){this.audioContext.state==="running"&&this.audioContext.suspend()},updateCurrentElement(e){this.currentElement=this.audioList.find(s=>s.title===e)},selectAudioByTitle(e){this.selectedAudioTitle=e,this.currentElement=this.audioList[this.audioList.findIndex(s=>s.title===e)]},areAllNodesAvailable(){return["musicSource","musicSplitter","microphoneSource","musicDevice","outputSplitter","musicGain","noiseSource","noiseSplitter","noiseDevice","noiseGain","merger"].every(s=>this.createdNodes[s]!==void 0)},handleIncompatibeError(e){if(e&&e.pop().context!==this.createdNodes.musicSplitter.context){const n=this.createdNodes.musicSplitter.context;this.createdNodes.musicSource||=n.createMediaElementSource(musicAudioElement)}},connectNodes(){try{const{musicSource:e,microphoneSource:s,musicGain:n,noiseSource:t,noiseSplitter:o,noiseDevice:i,noiseGain:c,merger:a}=this.createdNodes;if(!this.checkContextCompatibility&&!this.checkContextCompatibility)throw new Error("Incompatible audio context among nodes.");e.connect(n),t.connect(o),s.connect(i,0,0),o.connect(i,0,1),o.connect(i,1,2),i.connect(c),c.connect(a,0,0),c.connect(a,0,1),n.connect(a,0,2),n.connect(a,0,3),a.connect(a.context.destination)}catch{}},handlePlayingUpdate(e){const s=this.audioContext?this.audioContext:m().getContext();let n=null;if(e)if(this.areAllNodesAvailable()){this.disconnectNodes();const t=this.$refs[this.currentElement.title].$refs.audioElement,o=this.createdNodes.musicGain.gain.value,i=this.createdNodes.noiseGain.gain.value;this.$refs[this.currentElement.title].$refs.audioElement.muted=!1,this.$refs.Noise.$refs.audioElement.muted=!1,this.createdNodes.musicSource=null,this.createdNodes.musicSource=s.createMediaElementSource(t),this.connectNodes(),o>0&&o<=1&&this.createdNodes.musicGain.gain.linearRampToValueAtTime(o||1,s.currentTime+2),i>0&&i<=1&&this.createdNodes.noiseGain.gain.linearRampToValueAtTime(i||1,s.currentTime+3),this.audioContext.resume()}else navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!1,noiseSuppression:!1,autoGainControl:!1},video:!1}).then(t=>(n=this.audioContext.createMediaStreamSource(t),this.createdNodes.microphoneSource||=n,{audioContext:s,microphoneSource:n})).then(({audioContext:t,microphoneSource:o})=>p(t,this.noisePatch).then(i=>(this.createdNodes.noiseRNBODevice||=i,{audioContext:t,microphoneSource:o,noiseRNBODevice:i}))).then(({audioContext:t,microphoneSource:o,noiseRNBODevice:i})=>p(t,this.musicPatch).then(c=>(this.createdNodes.musicRNBODevice||=c,{audioContext:t,microphoneSource:o,noiseRNBODevice:i,musicRNBODevice:c}))).then(({audioContext:t,microphoneSource:o,noiseRNBODevice:i,musicRNBODevice:c})=>{const l=this.$refs[this.currentElement.title].$refs.audioElement;this.createdNodes||={},this.createdNodes.microphoneSource||=o,this.createdNodes.musicDevice||=c.node,this.createdNodes.noiseDevice||=i.node,this.createdNodes.noiseSource||=t.createMediaElementSource(this.$refs.Noise.$refs.audioElement),this.createdNodes.musicSource||=t.createMediaElementSource(l),this.createdNodes.musicSplitter||=t.createChannelSplitter(2),this.createdNodes.noiseSplitter||=t.createChannelSplitter(2),this.createdNodes.outputSplitter||=t.createChannelSplitter(2),this.createdNodes.musicGain||=t.createGain(),this.createdNodes.noiseGain||=t.createGain(),this.createdNodes.merger||=t.createChannelMerger(4),l.muted=!1,this.$refs.Noise.$refs.audioElement.muted=!1,this.createdNodes.musicGain.gain.value=1e-4,this.createdNodes.noiseGain.gain.value=1e-4,this.connectNodes(),setTimeout(()=>{this.playState=!0,this.createdNodes.musicGain.gain.exponentialRampToValueAtTime(1,t.currentTime+3),this.createdNodes.noiseGain.gain.exponentialRampToValueAtTime(1,t.currentTime+4),t.state==="suspended"&&this.resumeContext()},1e3)}).catch(t=>{this.disconnectNodes(),this.audioContext&&this.audioContext.destination.disconnect(),this.$toast.error("Oouh sorry! Error while setting up audio, please reload.")});else this.audioContext.suspend()},disconnectNodes(){typeof this.createdNodes=="object"&&this.createdNodes!==null&&(Object.values(this.createdNodes).forEach(e=>{e&&typeof e.disconnect=="function"&&e.disconnect(),e instanceof OscillatorNode&&e.stop()}),this.playState=!1)}}},S=e=>(T("data-v-f4aed5f9"),e=e(),y(),e),k=S(()=>r("h2",null,"You will hear the arifacts right after the music begins",-1)),w=S(()=>r("h2",null," These file contain both patches, use Gainsliders of AudioElement to control volume and allow to skip. AudioStore used for shared AudioContext. Music is connected directlly to the noise patch, way less glitches ",-1)),b={class:"rnboplayer"},V={key:0},M={class:"row"},U={class:"col-auto"},L={class:"col-auto"},P={class:"col-auto"};function I(e,s,n,t,o,i){const c=G("AudioElement");return d(),f("div",null,[k,w,r("div",b,[o.selectedAudioTitle?(d(),f("div",V,[A(C(i.selectedAudio.title)+" ",1),(d(),N(c,{ref:i.selectedAudio.title,key:i.selectedAudio.id,src:i.selectedAudio.src,title:i.selectedAudio.title,"onUpdate:playing":i.handlePlayingUpdate,"onUpdate:volume":i.changeMusicVolume},{default:g(({})=>[]),_:1},8,["src","title","onUpdate:playing","onUpdate:volume"]))])):E("",!0),(d(),N(c,{ref:o.noise.title,key:o.noise.id,src:o.noise.src,title:o.noise.title,"onUpdate:volume":i.changeNoiseVolume},{default:g(({})=>[]),_:1},8,["src","title","onUpdate:volume"])),r("div",M,[r("div",U,[r("button",{onClick:s[0]||(s[0]=(...a)=>i.skip&&i.skip(...a))}," Skip ")]),r("div",L,[r("button",{onClick:s[1]||(s[1]=(...a)=>i.resumeContext&&i.resumeContext(...a))}," Resume Context ")]),r("div",P,[r("button",{onClick:s[2]||(s[2]=(...a)=>i.stopContext&&i.stopContext(...a))}," Suspend Context ")])])])])}const q=v(_,[["render",I],["__scopeId","data-v-f4aed5f9"]]);export{q as default};
